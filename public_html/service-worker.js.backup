const CACHE_NAME = 'obekt-plus-v1';
const urlsToCache = [
  '/',
  '/projects',
  '/offline.html',
  '/css/app.css',
  '/js/app.js',
  '/manifest.json',
  '/images/icons/icon.svg'
];

// –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Service Worker –∏ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤
self.addEventListener('install', (event) => {
  console.log('[Service Worker] Installing...');
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('[Service Worker] Caching app shell');
        return cache.addAll(urlsToCache);
      })
      .catch((error) => {
        console.error('[Service Worker] Cache failed:', error);
      })
  );
  self.skipWaiting();
});

// –ê–∫—Ç–∏–≤–∞—Ü–∏—è Service Worker –∏ –æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∫–µ—à–µ–π
self.addEventListener('activate', (event) => {
  console.log('[Service Worker] Activating...');
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log('[Service Worker] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => {
      // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫—É—é –ø—Ä–æ–≤–µ—Ä–∫—É —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
      console.log('[Service Worker] Starting automatic background checks');
      startPeriodicCheck(10000); // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
    })
  );
  return self.clients.claim();
});

// –°—Ç—Ä–∞—Ç–µ–≥–∏—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è: Network First, –∑–∞—Ç–µ–º Cache
self.addEventListener('fetch', (event) => {
  // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–µ-GET –∑–∞–ø—Ä–æ—Å—ã
  if (event.request.method !== 'GET') {
    return;
  }

  // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º chrome extensions –∏ –¥—Ä—É–≥–∏–µ —Å—Ö–µ–º—ã
  if (!event.request.url.startsWith('http')) {
    return;
  }

  // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å—ã –∫ Vite dev server
  if (event.request.url.includes('127.0.0.1:5174') || event.request.url.includes('@vite')) {
    return;
  }

  event.respondWith(
    fetch(event.request)
      .then((response) => {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–∞
        if (!response || response.status !== 200 || response.type === 'error') {
          return response;
        }

        // –ö–ª–æ–Ω–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç –¥–ª—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
        const responseToCache = response.clone();

        caches.open(CACHE_NAME)
          .then((cache) => {
            cache.put(event.request, responseToCache);
          });

        return response;
      })
      .catch(async () => {
        // –ï—Å–ª–∏ —Å–µ—Ç—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–µ—à
        const cachedResponse = await caches.match(event.request);
        if (cachedResponse) {
          return cachedResponse;
        }

        // –ï—Å–ª–∏ –∑–∞–ø—Ä–æ—Å –∫ HTML —Å—Ç—Ä–∞–Ω–∏—Ü–µ –∏ –Ω–µ—Ç –≤ –∫–µ—à–µ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—Ñ–ª–∞–π–Ω —Å—Ç—Ä–∞–Ω–∏—Ü—É
        if (event.request.headers.get('accept')?.includes('text/html')) {
          const offlinePage = await caches.match('/offline.html');
          if (offlinePage) {
            return offlinePage;
          }
        }
        
        // –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≥–ª–∞–≤–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏–∑ –∫–µ—à–∞ –∏–ª–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
        const mainPage = await caches.match('/');
        if (mainPage) {
          return mainPage;
        }
        
        // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ—Ç –≤ –∫–µ—à–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤—ã–π –æ—Ç–≤–µ—Ç
        return new Response('Offline - no cache available', {
          status: 503,
          statusText: 'Service Unavailable',
          headers: new Headers({
            'Content-Type': 'text/plain'
          })
        });
      })
  );
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
self.addEventListener('push', (event) => {
  console.log('[Service Worker] Push event received', event);
  
  let notificationData = {
    title: '–û–±—ä–µ–∫—Ç+',
    body: '–ù–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ',
    icon: '/images/icons/icon-192x192.png',
    badge: '/images/icons/icon-96x96.png',
    url: '/'
  };

  // –ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ –∏–∑ push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
  if (event.data) {
    try {
      const data = event.data.json();
      console.log('[Service Worker] Push data:', data);
      notificationData = {
        title: data.title || notificationData.title,
        body: data.body || data.message || notificationData.body,
        icon: data.icon || notificationData.icon,
        badge: data.badge || notificationData.badge,
        url: data.url || data.link || notificationData.url,
        data: data
      };
    } catch (e) {
      console.log('[Service Worker] Push data as text:', event.data.text());
      notificationData.body = event.data.text();
    }
  } else {
    console.log('[Service Worker] No push data');
  }

  const options = {
    body: notificationData.body,
    icon: notificationData.icon,
    badge: notificationData.badge,
    vibrate: [200, 100, 200],
    data: {
      dateOfArrival: Date.now(),
      url: notificationData.url,
      ...notificationData.data
    },
    actions: [
      {
        action: 'open',
        title: '–û—Ç–∫—Ä—ã—Ç—å',
        icon: '/images/icons/icon-96x96.png'
      },
      {
        action: 'close',
        title: '–ó–∞–∫—Ä—ã—Ç—å',
        icon: '/images/icons/icon-96x96.png'
      }
    ],
    tag: notificationData.data?.tag || 'default-notification',
    requireInteraction: false,
    renotify: true
  };

  console.log('[Service Worker] Showing notification:', notificationData.title, options);

  event.waitUntil(
    self.registration.showNotification(notificationData.title, options)
      .then(() => {
        console.log('[Service Worker] Notification shown successfully');
      })
      .catch((error) => {
        console.error('[Service Worker] Error showing notification:', error);
      })
  );
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—é
self.addEventListener('notificationclick', (event) => {
  console.log('[Service Worker] Notification click:', event.action);
  
  event.notification.close();

  const urlToOpen = event.notification.data?.url || '/';

  if (event.action === 'open' || !event.action) {
    event.waitUntil(
      clients.matchAll({ type: 'window', includeUncontrolled: true })
        .then((clientList) => {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–æ–µ –æ–∫–Ω–æ
          for (let client of clientList) {
            if (client.url === urlToOpen && 'focus' in client) {
              return client.focus();
            }
          }
          // –ï—Å–ª–∏ –æ–∫–Ω–∞ –Ω–µ—Ç, –æ—Ç–∫—Ä—ã–≤–∞–µ–º –Ω–æ–≤–æ–µ
          if (clients.openWindow) {
            return clients.openWindow(urlToOpen);
          }
        })
        .then(() => {
          // –û—Ç–º–µ—á–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–∞–∫ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ
          const notificationId = event.notification.data?.notification_id;
          if (notificationId) {
            return fetch('/api/push/delivered', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              credentials: 'include',
              body: JSON.stringify({ notification_id: notificationId })
            });
          }
        })
    );
  }
});

// –°–ª—É—à–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã
self.addEventListener('message', (event) => {
  console.log('[Service Worker] Message received:', event.data);
  
  if (event.data.type === 'START_PERIODIC_CHECK') {
    const interval = event.data.interval || 60000; // 1 –º–∏–Ω—É—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    startPeriodicCheck(interval);
  }
});

// –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ setTimeout –≤ Service Worker
let periodicCheckTimer = null;

function startPeriodicCheck(interval) {
  console.log(`[Service Worker] Starting periodic check every ${interval}ms`);
  
  // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä
  if (periodicCheckTimer) {
    clearTimeout(periodicCheckTimer);
  }
  
  // –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
  async function doPeriodicCheck() {
    await checkForNotifications();
    
    // –ü–ª–∞–Ω–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â—É—é –ø—Ä–æ–≤–µ—Ä–∫—É
    periodicCheckTimer = setTimeout(doPeriodicCheck, interval);
  }
  
  // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—É—é –ø—Ä–æ–≤–µ—Ä–∫—É
  doPeriodicCheck();
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤ —Ñ–æ–Ω–µ (–Ω–∞ –±—É–¥—É—â–µ–µ)
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-data') {
    event.waitUntil(syncData());
  }
});

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤ —Ñ–æ–Ω–µ - –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–≤—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
self.addEventListener('sync', (event) => {
  console.log('[Service Worker] Background sync event:', event.tag);
  
  if (event.tag === 'check-notifications') {
    event.waitUntil(checkForNotifications());
  }
});

// –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è (–∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç)
self.addEventListener('periodicsync', (event) => {
  console.log('[Service Worker] Periodic sync event:', event.tag);
  
  if (event.tag === 'check-notifications-periodic') {
    event.waitUntil(checkForNotifications());
  }
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–≤—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
async function checkForNotifications() {
  try {
    console.log('[Service Worker] Checking for new notifications...');
    
    // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π ID –∏–∑ IndexedDB
    const lastId = await getLastNotificationId();
    
    // –í–ê–ñ–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ—Ä–æ—Ç–∫–∏–π timeout –¥–ª—è —Ñ–æ–Ω–æ–≤–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
    const response = await fetch(`/api/push/poll?timeout=2&last_id=${lastId || ''}`, {
      method: 'GET',
      headers: {
        'Accept': 'application/json'
      },
      credentials: 'include'
    });
    
    if (!response.ok) {
      console.error('[Service Worker] Failed to fetch notifications:', response.status);
      return;
    }
    
    const data = await response.json();
    
    if (data.success && data.notifications && data.notifications.length > 0) {
      console.log('[Service Worker] ‚úÖ Found', data.notifications.length, 'new notification(s)');
      
      // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –Ω–æ–≤—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
      for (const notification of data.notifications) {
        await showBackgroundNotification(notification);
        await saveLastNotificationId(notification.id);
        
        // –û—Ç–º–µ—á–∞–µ–º –∫–∞–∫ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ
        markAsDeliveredBackground(notification.id);
      }
    } else {
      console.log('[Service Worker] No new notifications');
    }
  } catch (error) {
    console.error('[Service Worker] Error checking notifications:', error);
  }
}

// –û—Ç–º–µ—Ç–∏—Ç—å –∫–∞–∫ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ –∏–∑ SW
async function markAsDeliveredBackground(notificationId) {
  try {
    await fetch('/api/push/, 100, 200], // –ë–æ–ª–µ–µ –∑–∞–º–µ—Ç–Ω–∞—è –≤–∏–±—Ä–∞—Ü–∏—è
    tag: data.id || 'notification-' + Date.now(),
    requireInteraction: true, // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    silent: false, // –°–æ –∑–≤—É–∫–æ–º
    renotify: true, // –£–≤–µ–¥–æ–º–ª—è—Ç—å –¥–∞–∂–µ –µ—Å–ª–∏ —Ç–∞–∫–æ–π tag —É–∂–µ –µ—Å—Ç—å
    data: {
      url: data.url || '/',
      notification_id: data.id,
      timestamp: data.timestamp
    },
    actions: [
      {
        action: 'open',
        title: '–û—Ç–∫—Ä—ã—Ç—å'
      },
      {
        action: 'close',
        title: '–ó–∞–∫—Ä—ã—Ç—å'
      }
    ]
  };
  
  console.log('[Service Worker] üîî Showing notification:', title);
  
  try {
    await self.registration.showNotification(title, options);
    console.log('[Service Worker] ‚úÖ Notification shown successfully');
  } catch (error) {
    console.error('[Service Worker] ‚ùå Error showing notification:', error);
  }
    data: {
      url: data.url || '/',
      notification_id: data.id,
      timestamp: data.timestamp
    },
    actions: [
      {
        action: 'open',
        title: '–û—Ç–∫—Ä—ã—Ç—å'
      },
      {
        action: 'close',
        title: '–ó–∞–∫—Ä—ã—Ç—å'
      }
    ]
  };
  
  console.log('[Service Worker] Showing notification:', title);
  
  return self.registration.showNotification(title, options);
}

// –°–æ—Ö—Ä–∞–Ω–∏—Ç—å ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ IndexedDB
async function saveLastNotificationId(id) {
  try {
    const db = await openNotificationDB();
    const tx = db.transaction('settings', 'readwrite');
    const store = tx.objectStore('settings');
    await store.put({ key: 'lastNotificationId', value: id });
    await tx.complete;
  } catch (error) {
    console.error('[Service Worker] Error saving last notification ID:', error);
  }
}

// –ü–æ–ª—É—á–∏—Ç—å ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∏–∑ IndexedDB
async function getLastNotificationId() {
  try {
    const db = await openNotificationDB();
    const tx = db.transaction('settings', 'readonly');
    const store = tx.objectStore('settings');
    const result = await store.get('lastNotificationId');
    return result?.value || null;
  } catch (error) {
    console.error('[Service Worker] Error getting last notification ID:', error);
    return null;
  }
}

// –û—Ç–∫—Ä—ã—Ç—å/—Å–æ–∑–¥–∞—Ç—å IndexedDB
function openNotificationDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('NotificationsDB', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('settings')) {
        db.createObjectStore('settings', { keyPath: 'key' });
      }
    };
  });
}

async function syncData() {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
  await checkForNotifications();
  console.log('[Service Worker] Background sync completed');
}
